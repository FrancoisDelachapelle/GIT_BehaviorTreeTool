{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fmodern JetBrains Mono;}}
{\colortbl ;\red255\green255\blue255;\red0\green0\blue255;\red255\green0\blue0;\red108\green149\blue235;\red208\green208\blue208;\red193\green145\blue255;\red189\green189\blue189;\red201\green162\blue109;\red57\green204\blue143;\red102\green195\blue204;\red133\green196\blue108;\red237\green148\blue192;\red120\green120\blue120;\red225\green191\blue255;\red71\green43\blue99;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 UI Builder\par
\par
Pr\'e9 install\'e9 sur unity 2021.1+. Sinon aller le chercher dans package Manager.\line Ouvre une fen\'eatre. \line Pour cr\'e9er un nouvel \'e9l\'e9ment, aller dans le + dans la fen\'eatre Project, UI Tool Kit, Editor Window. Donner un nom et ca va cr\'e9er 3 assets : un .cs, un USS, un UXML. \par
Le .cs c'est le fichier classique d'unity avec un # vert dessus. Le USS est indiqu\'e9 par des \{\} rouges et le UXML par un </> rouge. Double cliquer dessus pour l'ouvrir dans la fen\'eatre d'ui builder.\par
\par
On supprime le label automatique de la hierarchy, puis on on va dans le + dans stylesheet et on importe l'uss qu'on a cr\'e9\'e9. On suppr le label \'e9galement.\par
\par
Ensuite on ouvre le .cs :\line Suppr le VisualElement label et root.Add(label), celui du "hello world" et l'autre labelWithStyle qui est en dessous (garder le root.Add() vu qu'on y passe \'e0 la place du label le stylesheet qui est juste au dessus.\par
Attention il faut ajouter .styleSheets apr\'e8s le root. Vu que c'est \'e0 lui qu'on add notre styleSheet.\par
On remplace aussi le Instatiate() du labelFromUXML. On remplace par visualTree.CloneTree(). On y passe le root d'en dessous en param\'e8tre puis on suppr la ligne du root en dessous ainsi que le contneu qui est \'e9gal \'e0 ce visualTree.\par
Remplacer le instantiate par cloneTree permet de cr\'e9er un objet interm\'e9diaire qu'on peut g\'e9rer.\par
Si on veut, et \cf1\highlight2 c'est conseill\'e9 on peut faire un bouton de menu \cf0\highlight0 pour imm\'e9diatement ouvrir la fen\'eatre du tool. Pour cela ajouter l'attribut [MenuItem("pathDuMenuACreer/SuiteDuPathSiOnVeutUnSousMenu")]\par
\line on renomme showExample en OpenWindow (plus clair) ou ce que l'on veut qui fait sens pour l'utilisateur.\par
A ce stade, si on clic sur le bouton de menu qui s'est ajout\'e9 en haut avec les autres menus d'unity, cela devrait ouvrir \highlight3 une fen\'eatre appel\'e9e de la m\'eame mani\'e8re que le texte de la variable wnd.titleContent.\par
\highlight0 Exemple :\par

\pard\box\brdrdash\brdrw0 \sa200\sl240\slmult1\cf4\f1\fs20 public class \cf5\b BehaviorTreeEditorWindow \b0 : \cf6 EditorWindow\line\cf7\{\line     \highlight2 [\cf6 MenuItem\cf7 (\cf8 "BehaviorTreeEditorWindow/Editor ..."\cf7 )]\line\highlight0     \cf4 public static void \cf9 OpenWindow\cf7 ()\line     \{\line         \cf6 BehaviorTreeEditorWindow \cf7 wnd = \cf9 GetWindow\cf7 <\cf6 BehaviorTreeEditorWindow\cf7 >();\highlight3\line         wnd.\cf10 titleContent \cf7 = \cf4 new \cf6 GUIContent\cf7 (\cf8 "BehaviorTreeEditorWindow"\cf7 );\highlight0\line     \}\line\line     \cf4 public void \cf5\b CreateGUI\cf7\b0 ()\line     \{\line         \cf11\i // Each editor window contains a root VisualElement object\line         \cf6\i0 VisualElement \cf7 root = \cf10 rootVisualElement\cf7 ;\line         \line\line         \cf11\i // Import UXML\line         \cf4\i0 var \cf7 visualTree = \cf6 AssetDatabase\cf7 .\cf9 LoadAssetAtPath\cf7 <\cf6 VisualTreeAsset\cf7 >(\cf8 "Assets/Scripts/RunTime/BehaviorTreeInternals/BehaviorTreeEditorWindow.uxml"\cf7 );\line         visualTree.\cf9 CloneTree\cf7 (root);\line    \line\line         \cf11\i // A stylesheet can be added to a VisualElement.\line         // The style will be applied to the VisualElement and all of its children.\line         \cf4\i0 var \cf7 styleSheet = \cf6 AssetDatabase\cf7 .\cf9 LoadAssetAtPath\cf7 <\cf6 StyleSheet\cf7 >(\cf8 "Assets/Scripts/RunTime/BehaviorTreeInternals/BehaviorTreeEditorWindow.uss"\cf7 );\line         \cf5 root\cf7 .\cf5 styleSheets\cf7 .\cf5 Add\cf7 (\cf5 styleSheet\cf7 );\par
\cf0\f0\fs22 Ensuite, dans l'ui builder, on clic dans hierarchy sur le uxml. On check que la case Editor Extension Autoring est coch\'e9e dans l'inspector. Cela permet d'afficher plus d'options de widget Editor Only dans la library.\line Puis dans project settings, dans ui builder on coche \'e9galement la case concernant l'authoring. Cela devrait faire en sorte que la case qu'on a coch\'e9 pr\'e9c\'e9demment restera coch\'e9e par d\'e9faut dor\'e9navant.\par
\par
Le graphView \'e9tant exp\'e9rimental, elle n'apparait pas pas dans la liste des widgets. Mais on peut la faire apparaitre et travailler avec. Pour cela on cr\'e9\'e9 un nouveau .CS qu'on fait h\'e9riter de graphView. On peut nommer la classe MachinTrucView avec un View \'e0 la fin pour reconna\'eetre le type d'objet que c'est.\par
\par
Une fois le cs ouvert il faut ajouter les include UnityEditor.Experimental.GraphView et UnityEngine.UIElements, ensuite on reparente la classe avec GraphView.\line\line On y ajoute ensuite un constructor public BehaviourTreeView()\par
On ajoute \'e0 cette classe ensuite une nouvelle classe public new class UxmlFactory : UxmlFactory<BehaviourTreeView, GraphView.UxmlTraits>.\line On laisse le reste de la classe vide. Compiler et notre view devrait appara\'eetre dans la liste des custom controls. Pour les voir, aller dans library puis onglet Project.\line\line On va maintenant drag'n drop la view dans la hi\'e9rarchie. Elle sera s\'fbrement mal taill\'e9e. Pour cela cliquer dessus et dans la cat\'e9gorie flex, s'assurer que shrink et flex-grow sont tous les 2 \'e0 1. Les valeurs \'e9tant normalis\'e9es cela correspond \'e0 100% de la taille de la fen\'eatre.\par
\par
De retour sur notre code de graphView : On copie colle notre variable de stylesheets avec son add qu'on a vu pr\'e9c\'e9demment sur le cs de la window dans notre constructor. On doit juste retirer root vu que graphView poss\'e8de \'e9galement un styleSheet. Il faut toutefois rajouter l'include UnityEditor pour qu'il trouve la classe AssetDataBase.\par
\par
Ensuite on ajoute au dessus du stylesheet un Insert(0, new GridBackGround());\par
C'est une classe d'experimentalGraphView. On compile. la window a d\'fb changer de couleur et devenir noire tandis que l'on peut d\'e9rouler la hi\'e9rarchie de la view et trouver notre gridBackground dedans.\par
Pour constuire la grille qui servira de fond, il faut en plus de la classe, ajouter du contenu au fichier.USS qu l'on a cr\'e9\'e9 au d\'e9but.\line\cf6\f1\fs20 GridBackground \cf7\{\line     \cf4 --grid-background-color\cf7 : \cf9 rgb\cf7 (\cf12 40\cf7 , \cf12 40\cf7 , \cf12 40\cf7 );\line     \cf4 --line-color\cf7 : \cf9 rgba\cf7 (\cf12 193\cf7 , \cf12 196\cf7 , \cf12 192\cf7 , \cf12 0.1\cf7 );\line     \cf4 --thick-line-color\cf7 : \cf9 rgba\cf7 (\cf12 193\cf7 , \cf12 196\cf7 , \cf12 192\cf7 , \cf12 0.1\cf7 );\line     \cf4 --spacing\cf7 : \cf12 15\cf7 ;\line\}\par
\cf0\f0\fs22 Ce contenu donnera le m\'eame aspect de grille en fond que les BP d'unreal. On retourne \'e0 notre constructor : \line On y ajoute this.AddManipulator() 4 fois et en param\'e8tre on va passer l'un apr\'e8s l'autre : \line -new ContentZoomer() qui va permettre de zoomer et d\'e9zoomer.\line -new ContentDragger() qui permet de d\'e9placer la vue sur la grille.\line -new SelectionDragger() qui permet de d\'e9placer des nodes.\line - new rectangleSelector() qui permet de faire des selections de groupe. On compile.\line\line Si tout fonctionne, en cliquant sur preview, les bordures deviendront orange et on pourra manipuler notre griller comme sur l'editeur unreal.\line\par
\line Maintenant on veut ajouter un panel comme un inspector \'e0 notre fen\'eatre. Il doit \'eatre resizable. Pour cela on cr\'e9\'e9 un .cs qu'on appellera SplitView et un autre nomm\'e9 InspectorView.\par
\par
SplitView doit avoir l'include UnityEngine.UIElements et on le fait h\'e9riter de TwoPaneSplitView. Cette classe n'est pas exp\'e9rimentale et donc n'est pas n\'e9cessairement ajout\'e9e par d\'e9faut \'e0 l'UIBuilder.\par
Il va falloir faire comme pour le graphView et ajouter un UxmlFactory. sauf que cette fois ci ce sera <Splitview, TwoPaneSplitView.UxmlTraits> \'e0 l'int\'e9rieur.\line\line Pour l'inspectorView, il faut l'include UIElements comme l'autre et le faire h\'e9riter de VisualElement. Encore une fois on ajoute un UxmlFactory avec les r\'e8gles vues pr\'e9c\'e9demment. \line\line On compile, il y aura un message d'erreur comme quoi SplitView a besoin de 2enfants. On peut l'ignorer pour l'instant on le r\'e9pare apr\'e8s. On add le splitview \'e0 la hierarchy.\line On va dans library/standard et on drag'n drop 2 visual element qu'on parente \'e0 la splitview. On les renomme comme on le souhaite puis on drag la grille dans un des panels, puis l'inspectorView dans celui qui reste.\line\line Notre interface prend forme.\line On peut ensuite modifier la taille que prenne nos panels. Dans splitView on augmente/baisse la valeur de de Fixed Pane Initial Dimension. On la mettra ici \'e0 300. On va \'e9glament augmenter les dimensions de la window (800*600)\par
On ajoute ensuite une toolBar \'e0 la hierarchy. Pas dans le splitview par contre. Puis on y parente un toolBarMenu. Notez qu'on peut \'e9galement les drag dans la preview et \'e7a fonctionne.\par
On drag ensuite 2 label, un dans chaque panel. On les renomme Inspector et Tree View.\line\par
\par
Les nodes\line On cr\'e9\'e9 ensuite le scriptable Object BehaviorTree gr\'e2ce au bouton fait pr\'e9alablement. On ouvre le cs du behaviorTree (pas le component). On lui donne 2 fonctions en plus de ce qu'on lui d\'e9j\'e0 donn\'e9. \line public TreeNode CreateNode(System.Type _type) et public void DeleteNode(TreeNode _node)\line On donne aussi \'e0 TreeNode une var string guid.\line\line\cf4\f1\fs20 public \cf6 TreeNode \cf13 CreateNode\cf7 (\cf13 System.\cf6 Type \cf7 _type)\line\{\line     \cf6 TreeNode \cf7 _node = \cf13 ScriptableObject.\cf9 CreateInstance\cf7 (_type) \cf4 as \cf6 TreeNode\cf7 ;\line     _node.\cf10 name \cf7 = _type.\cf10 Name\cf7 ;\line     _node.\cf10 guid \cf7 = \cf14 GUID\cf7 .\cf9 Generate\cf7 ().\cf9 ToString\cf7 (); \cf11\i //Gives a unique\line     \cf10\i0 allNodes\cf7 .\cf9 Add\cf7 (_node);\line     \line     \cf6 AssetDatabase\cf7 .\cf9 AddObjectToAsset\cf7 (_node, \cf4 this\cf7 );\line     \cf6 AssetDatabase\cf7 .\cf9 SaveAssets\cf7 ();\line     \cf4 return \cf7 _node;\line\}\line\line\cf4 public void \cf13 DeleteNode\cf7 (\cf6 TreeNode \cf7 _node)\line\{\line     \cf10 allNodes\cf7 .\cf9 Remove\cf7 (_node);\line     \cf6 AssetDatabase\cf7 .\cf9 RemoveObjectFromAsset\cf7 (_node);\line     \cf6 AssetDatabase\cf7 .\cf9 SaveAssets\cf7 ();\line\}\par
\cf0\f0\fs22\line On a ce qu'il faut pour cr\'e9er/d\'e9truire nos nodes mais il nous manque l'interface et les commandes pour les int\'e9grer au tool.\par
\par
Pour faire cela on ajoute \'e0 notre classe BehaviorTreeEditorWindow la fonction OnSelectionChange. On add les variables de BehaviorTreeView et InspectorView.\par
Dans la fonction CreateGUI, on les r\'e9cup\'e8re depuis notre window. treeView = root.Query<BehaviorTreeView>(); et idem pour l'inspectoView.\par
\par
Ensuite on rempli OnSelectionchange avec : \line BehaviorTree _tree = Selection.activeObject as BehaviorTree;\line if(_tree)\{\line  \tab treeView.PopulateView(_tree);\}\par
Il faut cr\'e9er cette fonction vu qu'on ne l'a pas encore fait.\line On cr\'e9\'e9 une fonction internal void PopulateView qui prend un BehaviorTree en param\'e8tre.\line on ajoute une variable \'e0 la classe BehaviorTreeView BehaviorTree pour stocker l'arbre que cette view affiche.\line La fonction va donc set cette variable : tree = _tree;\line DeleteElements(graphElements); => On vide toute l'UI des fois qu'on aurait ouvert un autre arbre auparavant afin de purger tout reste. graphElements est une variable de la classe mere.\line Puis on fait tree.AllNodes(n => CreateNodeView(n)).  => ForEach qui appeler la cr\'e9taion de la view de chaque node pour chaque \'e9l\'e9ment de l'arbre.\line\line On cr\'e9\'e9 ensuite cette focntion juste en dessous dans la classe BehaviorTreeView. \line void CreateNodeView(TreeNode _node)\par
Cette fonction cr\'e9\'e9 un NodeView, une classe qu'on cr\'e9\'e9ra apr\'e8s. NodeView _nodeView = new NodeView(_node);\line AddElement(_nodeView) => fonction d\'e9j\'e0 faite s\'e9curis\'e9e pour ajouter un \'e9l\'e9ment \'e0 la liste de l'UI. Recommand\'e9 de l'utilier plut\'f4t que de chercher la liste des \'e9l\'e9ments et faire Add.\line\par
La classe NodeView ressemble \'e0 \'e7a :\line\cf4\f1\fs20 public class \cf6 NodeView \cf5 : \cf6 UnityEditor\cf7 .\cf6 Experimental\cf7 .\cf6 GraphView\cf7 .\cf6 Node\line\cf7\{\line     \cf4 public \cf6 TreeNode \cf13 node = null\cf7 ;\line     \cf4 public \cf6 NodeView\cf7 (\cf6 TreeNode \cf7 _node)\line     \{\line         \cf13 this.\cf10 node \cf7 = _node;\line         \cf13 this.\cf10 title \cf7 = _node.\cf10 name\cf7 ;\line     \}\line\}\par
\cf0\f0\fs22\par
Retour dans BehaviorTreeView. On ajoute la fonction override BuildContextualMenu(ContextualMenuPopulateEvent evt) dont on commente le super.\line\par
Dans cette focntion on cr\'e9\'e9 un bloc ind\'e9pendant de \{\} dans lequel on ajoute ce code : \line\cf4\f1\fs20 var \cf7 _types = \cf6 TypeCache\cf7 .\cf9 GetTypesDerivedFrom\cf7 <\cf6 Leaf\cf7 >();\line\cf4 foreach \cf7 (\cf4 var \cf7 _type \cf4 in \cf7 _types)\line\{\line     evt.\cf10 menu\cf7 .\cf9 AppendAction\cf7 (\cf8 $"[\{\cf7 _type.\cf10 BaseType\cf7 .\cf10 Name\cf8\}] \{\cf7 _type.\cf10 Name\cf8\}"\cf7 , \cf13 (a) \cf5 => \cf9 CreateNode\cf7 (_type));\line\}\par
\cf0\f0\fs22 Cela permet d'aller chercher par r\'e9fl\'e9xion  tous les types d\'e9rivant de Leaf et pour chacun de les ajouter au menu les affichant en tant que bouton cliquable. Cela montrera : [type d'origine] nom du node. C'est le nom du bouton, et l'action est de cr\'e9er ce node.\par
On CopieColle ce bloc 2 fois pour faire aussi apparaitre les composite et decorator.\line\line Pour que ces blocs fonctionnent, il faut aussi cr\'e9er la fonction CreateNode(System.Type _type)\line Elle contiendra : \line TreeNode _node = tree.CreateNode(_type);\line CreateNodeView(_node);\line\line Compiler et maintenant en testant, avec le clic droit \'e7a devrait faire appara\'eetre le menu permettant de faire spawn les nodes. Ca devrait afficher tous les nodes cr\'e9\'e9s actuellement qui descendent des types fournis dans le contextualMenu. Cliquer sur ces boutons devrait faire appara\'eetre les nodes sur la grille.\line\ul\b ATTENTION : il faut avoir le ScriptableObject selectionn\'e9 dans le content Drawer.\line\ulnone\b0\line Pour que les nodes voient leur position sauvegard\'e9e, il faut aller dans TreeNode, lui donner un membre Vector2 position. Puis aller dans NodeView et override la fonction setPosition.\line Dedans on laisse le super et on ajoute node.Position.x/y = newPos.x/yMin;\line\line puis dans le constructeur au dessus, il faut faire style.left = node.Position.x et style.top = node.Position.y\par
il faut \'e9galement mettre dans PopulateView dans BehaviorTreeView : graphViewChanged -= OnGraphViewChanged juste apr\'e8s le set du tree. Puis on r\'e9abonne graphViewChanged \'e0 cette fonction juste avant le forEach. De cette mani\'e8re, la grille est reset quand les elements sont vid\'e9s \'e0 une nouvelle ouverture.\line\line La fonction OnGraphViewChanged doit \'eatre faite : \line\cf4\f1\fs20 if \cf7 (_graphviewchange.\cf10 elementsToRemove \cf7 != \cf4 null\cf7 )\line\{\line     _graphviewchange.\cf10 elementsToRemove\cf7 .\cf9 ForEach\cf7 (elem \cf5 =>\line     \cf7\{\line         \cf6 NodeView \cf7 _nodeView = elem \cf4 as \cf6 NodeView\cf7 ;\line         \cf4 if\cf7 (_nodeView != \cf4 null\cf7 )\line             \cf10 tree\cf7 .\cf9 DeleteNode\cf7 (_nodeView.\cf10 node\cf7 );\line     \});\line\}\line\cf4 return \cf7 _graphviewchange;\par
\cf0\f0\fs22\par
Ensuite on ajoute 2 fonctions dans cette m\'eame classe nodeview. CreateInputPorts() et CreateOutputPorts(). On les cr\'e9\'e9.\line\line Dedans il doit y avoir \'e7a : \line\cf4\f1\fs20 if \cf7 (\cf10 node \cf4 is \cf6 Leaf\cf7 )\line\{\line     \cf10 input \cf7 = \cf9 InstantiatePort\cf7 (\cf14 Orientation\cf7 .\cf10\b Horizontal\cf7\b0 , \cf14 Direction\cf7 .\cf10\b Input\cf7\b0 , \cf6 Port\cf7 .\cf14 Capacity\cf7 .\cf10\b Single\cf7\b0 , \cf4 typeof\cf7 (\cf4 bool\cf7 ));\line\}\line\cf4 else if \cf7 (\cf10 node \cf4 is \cf6 Composite\cf7 )\line\{\line     \cf10 input \cf7 = \cf9 InstantiatePort\cf7 (\cf14 Orientation\cf7 .\cf10\b Horizontal\cf7\b0 , \cf14 Direction\cf7 .\cf10\b Input\cf7\b0 , \cf6 Port\cf7 .\cf14 Capacity\cf7 .\cf10\b Single\cf7\b0 , \cf4 typeof\cf7 (\cf4 bool\cf7 ));\line\}\line\cf4 else if \cf7 (\cf10 node \cf4 is \cf6 Decorator\cf7 )\line\{\line     \cf10 input \cf7 = \cf9 InstantiatePort\cf7 (\cf14 Orientation\cf7 .\cf10\b Horizontal\cf7\b0 , \cf14 Direction\cf7 .\cf10\b Input\cf7\b0 , \cf6 Port\cf7 .\cf14 Capacity\cf7 .\cf10\b Single\cf7\b0 , \cf4 typeof\cf7 (\cf4 bool\cf7 ));\line\}\line\line\cf4 if \cf7 (\cf10 input \cf7 != \cf4 null\cf7 )\line\{\line     \cf10 input\cf7 .\cf10 portName \cf7 = \cf8 ""\cf7 ;\line     \cf10 inputContainer\cf7 .\cf9 Add\cf7 (\cf10 input\cf7 );\line\}\highlight15\par
\cf0\highlight0\f0\fs22\par
Ce sont les entr\'e9es et sorties des nodes. Pour chaque type on d\'e9termine l'orientation du port d'entr\'e9e et de sortie (Orientation). Le deuxi\'e8me param, Direction, d\'e9termine si le port doit accepter des entr\'e9es ou des sorties. Le troisi\'e8me, Port.Capacity, combien de liens ce port peut entretenir \'e0 la fois. enfin , le dernier param\'e8tre est le type du port, on veut que ce soit un bool (typeof(bool)).\line\line La fonction CreateOutputPorts sera similaire seulement, le nodeleaf ne pouvant pas avoir d'enfant, il n'y a pas lieu d'instancier de port d'output. Pour le composite il faut qu'il puisse sortir plusieurs liens car plusieurs enfants possibles et le decorator seulement 1. donc on laisse Single en Capacity.\par
\par
ensuite quand c'est fait il faut encore ajouter ces ports \'e0 la liste. Donc on fait outPut/inputContainer.Add(output/input). Juste avant on ajoute aussi une ligne pour changer le nom du port avec input.portName = "". On doit le set sinon il prendra le nom du type de lien que l'on veut. Ici bool.\line\line Maintenant on retourne dans BehaviorTreeView pour y ajouter la fonction override GetCompatiblePorts. Cette fonction retournera ports.ToList().Where(endport => \line endPort.direction != startPort.diection && endPort.node != startPort.node).ToList();\line\line Cette fonction permet de trier automatiquement les ports compatibles ensemble.\line\line Compiler. Ici les nodes devraient pouvoir se connecter ensemble et si on essaye de connecter 2 liens sur un node dont le port d'entr\'e9e n'en accepte qu'un alors le pr\'e9c\'e9dent devrait se d\'e9brancher.\line\line Pour la suite, on constate que m\'eame si on branche les nodes ensemble, la liste actuelle des enfants de chaque node ne se remplit pas. On va y rem\'e9dier.\line\line Dans BehaviorTree.cs, on va ajouter les fonctions AddChild(TreeNode _parent, TreeNode _child), RemoveChild(TreeNode _parent, TreeNode _child) et GetChildren(TreeNode _parent) qui elle, retourne une liste de TreeNode comme pr\'e9vu.\line\line Seuls les nodes Decorator et Composite peuvent avoir un ou plusieurs enfants. Donc on doit juste cast les types pour le parent et dans chaque cas donner le param\'e8tre _child comme leur enfant soit en le settant soit en .Add(_child). Idem pour le remove mais avec null et Remove.\line Pour le get, on cr\'e9er une liste temporaire pour stocker nos enfants pour g\'e9rer le d\'e9corator et on return \'e7a. \line ATTENTION : le child du decorator peut-\'eatre null ! Inutile alors de le retourner.\par
\line Maintenant on retourne dans BehaviorTreeView et avant le return dans la fonction OnGraphViewChanged, on rajoute :\line\cf4\f1\fs20 if \cf7 (_graphviewchange.\cf10 edgesToCreate \cf7 != \cf4 null\cf7 )\line\{\line     _graphviewchange.\cf10 edgesToCreate\cf7 .\cf9 ForEach\cf7 (edge \cf5 =>\line     \cf7\{\line         \cf6 NodeView \cf7 _parentView = edge.\cf10 output\cf7 .\cf10 node \cf4 as \cf6 NodeView\cf7 ;\line         \cf6 NodeView \cf7 _childView = edge.\cf10 input\cf7 .\cf10 node \cf4 as \cf6 NodeView\cf7 ;\line         \cf10 tree\cf7 .\cf9 AddChild\cf7 (_parentView.\cf10 node\cf7 , _childView.\cf10 node\cf7 );\line     \});\line\}\par
\cf0\f0\fs22 De ce fait, d\'e9sormais \'e0 chaque fois uq'on connectera un node, le parent recevra le node connect\'e9 comme enfant dans sa liste.\line\line Pour le suppression, il faut ajouter cela dans le elementsToRemove.ForEach d'au dessus (dans la m\'eame fonction).\line\cf6\f1\fs20 Edge \cf7 _edge = elem \cf4 as \cf6 Edge\cf7 ;\line\cf4 if \cf7 (_edge != \cf4 null\cf7 )\line\{\line     \cf6 NodeView \cf7 _parentView = _edge.\cf10 output\cf7 .\cf10 node \cf4 as \cf6 NodeView\cf7 ;\line     \cf6 NodeView \cf7 _childView = _edge.\cf10 input\cf7 .\cf10 node \cf4 as \cf6 NodeView\cf7 ;\line     \cf10 tree\cf7 .\cf9 RemoveChild\cf7 (_parentView.\cf10 node\cf7 , _childView.\cf10 node\cf7 );\line\}\par
\cf0\f0\fs22\par
Ensuite on modifie PopulateView en ajoutant apr\'e8s la fin : \line\cf10\f1\fs20 tree\cf7 .\cf10 AllNodes\cf7 .\cf9 ForEach\cf7 (n \cf5 =>\line\cf7\{\line     \cf4 var \cf7 _children = \cf10 tree\cf7 .\cf9 GetChildren\cf7 (n);\line     _children.\cf9 ForEach\cf7 (\cf13 c \cf5 => \line     \cf7\{\line         \line     \});\line\});\par
\cf0\f0\fs22 On doit maintenant ajouter une fonction qui v nous retourner un nodeView. FindNodeView(TreeNode _node) qui retourne imm\'e9diatement GetNodeByGuid(_node.guid) as NodeView.\par
\par
Cela fait on retourne dans PopulateView dans le double foreach pour ajouter dans celui des children :\line\cf6\f1\fs20 NodeView \cf7 _parentView = \cf9 FindNodeView\cf7 (n);\line\cf6 NodeView \cf7 _childView = \cf9 FindNodeView\cf7 (c);\line\line\cf6 Edge \cf7 _edge = _parentView.\cf10 output\cf7 .\cf9 ConnectTo\cf7 (_childView.\cf10 input\cf7 );\line\cf5 AddElement\cf7 (\cf5 _edge\cf7 );\par
\cf0\f0\fs22\line Ceci fonctionne car on a enregistr\'e9 chaque TreeNode dans un NodeView au pr\'e9alable et qu'ils sont reconnus par leur cl\'e9 guid qui est unique.\par
\line D\'e9sormais si on quitte la vue/focus du tree, les edges resteront connect\'e9es. M\'eame si on cr\'e9\'e9 un nouvel arbre et qu'on le focus puis qu'on retourne sur l'ancien, les edges se remettront correctement.\par
\par
\ul\b Maintenant on va impl\'e9menter l'inspector view.\ulnone\b0\par
Dans NodeView on va override une fonction : OnSelected()\line On ajoute un Action<NodeView> OnNodeSelected = null \'e0 la classe.\par
Deretour dans cette fonction : On laisse le base.OnSelected et on ajoute \'e0 la suite, OnNodeSelected?.Invoke(this);\line\line On C/C ensuite l'action juste cr\'e9\'e9e dans le BehaviorTreeView et dans la fonction locale CreateNodeView, avant le AddElement, on ajoute nodeView.OnSelected = OnNodeSelected;\line\par
Maintenant on part dans la classe BehaviorTreeEditorWindow. On y cr\'e9\'e9 une func OnNodeSelectionChange(NodeView _nodeView) de type void, et on ajoute dans CreateGUI juste avant OnSelectionChange(), treeView.OnNodeSelected = OnNodeSelectionChanged.\par
Dans cette fonction on met la ligne inspectorView.UpdateSelection(_nodeView). Cette fonction n'ex\'e7stant pas encore, on la cr\'e9\'e9 dans la classe InpsectorView. On doit y ajouter le using UnityEditor et on cr\'e9\'e9 une var membre Editor editor = null;\line\line De retour dans la fonction UpdateSelection(NodeView _nodeView), on met un Clear(); pour retirer la selection pr\'e9c\'e9dente si il y en a et ensuite UnityEngine.Object.DestroyImmediate(editor); suivi de editor = Editor.CreateEditor(_nodeView.node);\line => Il s'agit ici de ne pas avoir plusieurs editor existants pour \'e9viter des conflits ou impr\'e9cisions (d\'e9doublements par exemple). A la ligne suivante on \'e9crit IMGUIContainer _container = new IMGUIContainer(() => \{editor.OnInpsectorGUI();\}); Enfin on on fait Add(_container);\par
\line Du coup on a finalement un inspectorView qui fonctionne si on clique sur un des nodes. Le probl\'e8me c'est que c'est plein d'infos dont l'utilisateur lambda n'a pas besoin. Il faut donc les cacher. Pour ce faire on va donc ajouter aux attributs [HideInInspector] pour chaque membre qu'on souhaite retirer de l'inspector.\par
\par
ATTENTION : Ne pas confondre les nodes surtout s'ils ont des noms tr\'e8s proches, on pourait \'eatre amener \'e0 faire du faux debugging. \line ATTENTION : Ne pas supprimer de .cs s'il est utilis\'e9 dans un des BT. Il garderait en m\'e9moire un .cs invalide et on ne peut pas le supprimer. Il faudrait d\'e9truire l'arbre et le refaire. \line\cf3 TODO \cf0 : une modif pour fix \'e7a.\line\line\line\line\ul\b Cr\'e9er le ROOT Node du BT\ulnone\b0\line\par
On cr\'e9er un .cs RootNode ou Root. C'est un node cr\'e9\'e9 au m\'eame niveau que le decorator, leaf ou composite. Il ne poss\'e8de qu'un enfant. Dans son process on retourne l'execute() de son enfant. Il faut ensuite g\'e9rer les fonctions AddChild, removeChild et GetChildren pour le g\'e9rer dans BehaviorTree.cs. Il a normalement le m\'eame fonctionnement que le Decorator donc on peut C/C. \line Ensuite \'e7a se passe dans NodeView o\'f9 une fois encore on g\'e8re les inputs et outputs. Dans input on le g\'e8re mais on met rien dans son else if et dans output c'est le m\'eame que decorator encore une fois. \line\line Puis on va dans BehaviorTreeView, dans PopulateView, il faut g\'e9rer la cr\'e9ation s'il n'existe pas d\'e9j\'e0 du root.\line On ajoute donc \'e7a entre la cr\'e9ation des NodeView et GraphChange : \line\cf4\f1\fs20 if \cf7 (\cf5 !\cf10 tree\cf7 .\cf10 Root\cf7 )\line\{\line     \cf10 tree\cf7 .\cf10 Root \cf7 = \cf10 tree\cf7 .\cf9 CreateNode\cf7 (\cf4 typeof\cf7 (\cf6 Root\cf7 )) \cf4 as \cf6 Root\cf7 ;\line     \cf6 EditorUtility\cf7 .\cf9 SetDirty\cf7 (\cf10 tree\cf7 );\line     \cf6 AssetDatabase\cf7 .\cf9 SaveAssets\cf7 ();\line\}\highlight15\par
\cf0\highlight0\f0\fs22 Ensuite pour corriger un bug lors de la cr\'e9ation d'un nouvel arbre( il va tenter de cr\'e9er le root alors que le BT est pas totalement charg\'e9 et cr\'e9er une erreur de type "impossible d'ajouter un sous objet \'e0 un objet non serializable" ou un truc du genre).\line Donc pour le corriger on va dans BehaviorTreeEditorWindow, dans OnSelectionChange() dans le if(tree), on ajoute \'e0 la condition && AssetDatabase.CanOpenAssetInEditor(_tree.GetInstanceID())\line\line\par
Maintenant, il va s'agir de g\'e9rer l'instanciation et le runtime du BT\line\line Pour \'e9viter que 2 GO avec le m\'eame arbre \'e9ditent la m\'eame instance il va falloir cloner les arbres que l'on appelle.\line\line Pour cela on va d\'e9j\'e0 aller dans TreeNode et on cr\'e9\'e9 la fonction public virtual TreeNode Clone() qui contient return Instantiate(this) qui va permettre au node de se d\'e9doubler.\line Il va ensuite falloir impl\'e9menter cette fonction dans chaque cat\'e9gorie de node (root, decorator etc...)\par
\cf4\f1\fs20 public override \cf6 TreeNode \cf9 Clone\cf7 ()\line\{\line     \cf6 Root \cf7 _node = \cf9 Instantiate\cf7 (\cf4 this\cf7 );\line     _node.\cf10 child \cf7 = \cf10 child\cf7 .\cf9 Clone\cf7 ();\line     \cf4 return \cf7 _node;\line\}\highlight15\par
\cf0\highlight0\f0\fs22 Il faut r\'e9p\'e9ter cette fonction en modifiant comme il faut les \'e9l\'e9ments.\line Ensuite dans BeahviorTree : \line\cf4\f1\fs20 public \cf6 BehaviorTree \cf9 Clone\cf7 ()\line\{\line     \cf6 BehaviorTree \cf7 _tree = \cf9 Instantiate\cf7 (\cf4 this\cf7 );\line     _tree.\cf10 Root \cf7 = (\cf6 Root\cf7 )_tree.\cf10 Root\cf7 .\cf9 Clone\cf7 ();\line     \cf4 return \cf7 _tree;\line\}\highlight15\par
\cf0\highlight0\f0\fs22 Cette fonction est ensuite appel\'e9e au Start du BehaviorTreeComponent.\line currentTree = currentTree.Clone(); De cette mani\'e8re l'objet set n'est pas modifi\'e9 on a une copie pour tout changer durant le Play.\par
A partir de l\'e0, le BehaviorTree tourne correctement. Il faudra encore l'am\'e9liorer pour le mettre vertical, ajouter de la couleur, faire le blackBoard etc...\par
\par
\par
\par
\par
\par
\par
}
 